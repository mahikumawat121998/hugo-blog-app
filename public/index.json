[{"content":"Test Connection\n","summary":"\u003cp\u003eTest Connection\u003c/p\u003e","title":"Authentication with Next.js and Prisma","url":"/authentication-nextjs-prisma/"},{"content":"When it comes to backend development in Node.js, two names frequently stand out: Express.js and NestJS. While both are powerful and widely used, they differ greatly in terms of architecture, scalability, learning curve, and developer experience.\nIn this blog post, let‚Äôs explore the differences, use cases, pros and cons of Express.js and NestJS, so you can decide which framework suits your next project best.\nüß† What is Express.js? Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. It‚Äôs been around since 2010 and is known for its simplicity and speed.\n‚úÖ Pros: Lightweight and minimalistic. Huge community and tons of middleware. Easy to learn for beginners. Full control over architecture and design. ‚ùå Cons: No out-of-the-box structure ‚Äî everything must be built manually. Can become messy and hard to maintain in large applications. Lacks advanced features like dependency injection or modularization. üèóÔ∏è What is NestJS? NestJS is a progressive Node.js framework built with TypeScript, heavily inspired by Angular. It provides a highly structured and opinionated architecture out of the box, making it ideal for scalable enterprise applications.\n‚úÖ Pros: Built-in support for TypeScript and modular architecture. Powerful Dependency Injection (DI) system. Supports MVC, REST APIs, GraphQL, Microservices, and more. Out-of-the-box testing support and decorators. Easily maintainable and scalable codebase. ‚ùå Cons: Steeper learning curve, especially for beginners. More boilerplate compared to Express.js. Overhead might not be worth it for small/simple projects. üìä Side-by-Side Comparison Feature Express.js NestJS TypeScript Support Optional Built-in (recommended) Architecture Minimal, unopinionated Modular, opinionated (MVC/DI) Learning Curve Easy Moderate to Advanced Project Structure You define it Comes structured out-of-the-box Community Support Huge Growing rapidly Performance High (bare-bones) Slight overhead due to abstraction Best Use Cases Small apps, APIs, MVPs Large apps, enterprise-level APIs üì¶ When to Choose Express.js? You\u0026rsquo;re building a small-to-medium web service or REST API. You need full control and flexibility. You prefer simplicity over structure. You want to build a quick MVP or prototype. üöÄ When to Choose NestJS? You\u0026rsquo;re building a large-scale, enterprise-grade application. You love working with TypeScript. You want modular, testable, and maintainable code. You\u0026rsquo;re planning a microservices architecture or GraphQL API. üîö Final Thoughts Both Express.js and NestJS are excellent choices for backend development in Node.js. The decision comes down to project complexity, team experience, and scalability requirements.\nChoose Express.js for simplicity and control. Choose NestJS for structure, scalability, and productivity in larger applications. üí° Tip: If you\u0026rsquo;re working solo or on a small project, Express is quick and lightweight. But if you\u0026rsquo;re working on a long-term or team project, NestJS is definitely worth the learning curve.\nWhat do you prefer ‚Äî Express.js or NestJS? Share your thoughts in the comments!\n","summary":"\u003cp\u003eWhen it comes to backend development in \u003cstrong\u003eNode.js\u003c/strong\u003e, two names frequently stand out: \u003cstrong\u003eExpress.js\u003c/strong\u003e and \u003cstrong\u003eNestJS\u003c/strong\u003e. While both are powerful and widely used, they differ greatly in terms of architecture, scalability, learning curve, and developer experience.\u003c/p\u003e\n\u003cp\u003eIn this blog post, let‚Äôs explore the differences, use cases, pros and cons of \u003cstrong\u003eExpress.js\u003c/strong\u003e and \u003cstrong\u003eNestJS\u003c/strong\u003e, so you can decide which framework suits your next project best.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-what-is-expressjs\"\u003eüß† What is Express.js?\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://expressjs.com/\"\u003eExpress.js\u003c/a\u003e is a \u003cstrong\u003eminimal and flexible Node.js web application framework\u003c/strong\u003e that provides a robust set of features for web and mobile applications. It‚Äôs been around since 2010 and is known for its simplicity and speed.\u003c/p\u003e","title":"Express vs NestJS: Which One Should You Choose?","url":"/my-seventh-post/"},{"content":"When it comes to backend development in Node.js, two names frequently stand out: Express.js and NestJS. While both are powerful and widely used, they differ greatly in terms of architecture, scalability, learning curve, and developer experience.\nIn this blog post, let‚Äôs explore the differences, use cases, pros and cons of Express.js and NestJS, so you can decide which framework suits your next project best.\nüß† What is Express.js? Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. It‚Äôs been around since 2010 and is known for its simplicity and speed.\n‚úÖ Pros: Lightweight and minimalistic. Huge community and tons of middleware. Easy to learn for beginners. Full control over architecture and design. ‚ùå Cons: No out-of-the-box structure ‚Äî everything must be built manually. Can become messy and hard to maintain in large applications. Lacks advanced features like dependency injection or modularization. üèóÔ∏è What is NestJS? NestJS is a progressive Node.js framework built with TypeScript, heavily inspired by Angular. It provides a highly structured and opinionated architecture out of the box, making it ideal for scalable enterprise applications.\n‚úÖ Pros: Built-in support for TypeScript and modular architecture. Powerful Dependency Injection (DI) system. Supports MVC, REST APIs, GraphQL, Microservices, and more. Out-of-the-box testing support and decorators. Easily maintainable and scalable codebase. ‚ùå Cons: Steeper learning curve, especially for beginners. More boilerplate compared to Express.js. Overhead might not be worth it for small/simple projects. üìä Side-by-Side Comparison Feature Express.js NestJS TypeScript Support Optional Built-in (recommended) Architecture Minimal, unopinionated Modular, opinionated (MVC/DI) Learning Curve Easy Moderate to Advanced Project Structure You define it Comes structured out-of-the-box Community Support Huge Growing rapidly Performance High (bare-bones) Slight overhead due to abstraction Best Use Cases Small apps, APIs, MVPs Large apps, enterprise-level APIs üì¶ When to Choose Express.js? You\u0026rsquo;re building a small-to-medium web service or REST API. You need full control and flexibility. You prefer simplicity over structure. You want to build a quick MVP or prototype. üöÄ When to Choose NestJS? You\u0026rsquo;re building a large-scale, enterprise-grade application. You love working with TypeScript. You want modular, testable, and maintainable code. You\u0026rsquo;re planning a microservices architecture or GraphQL API. üîö Final Thoughts Both Express.js and NestJS are excellent choices for backend development in Node.js. The decision comes down to project complexity, team experience, and scalability requirements.\nChoose Express.js for simplicity and control. Choose NestJS for structure, scalability, and productivity in larger applications. üí° Tip: If you\u0026rsquo;re working solo or on a small project, Express is quick and lightweight. But if you\u0026rsquo;re working on a long-term or team project, NestJS is definitely worth the learning curve.\nWhat do you prefer ‚Äî Express.js or NestJS? Share your thoughts in the comments!\n","summary":"\u003cp\u003eWhen it comes to backend development in \u003cstrong\u003eNode.js\u003c/strong\u003e, two names frequently stand out: \u003cstrong\u003eExpress.js\u003c/strong\u003e and \u003cstrong\u003eNestJS\u003c/strong\u003e. While both are powerful and widely used, they differ greatly in terms of architecture, scalability, learning curve, and developer experience.\u003c/p\u003e\n\u003cp\u003eIn this blog post, let‚Äôs explore the differences, use cases, pros and cons of \u003cstrong\u003eExpress.js\u003c/strong\u003e and \u003cstrong\u003eNestJS\u003c/strong\u003e, so you can decide which framework suits your next project best.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-what-is-expressjs\"\u003eüß† What is Express.js?\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://expressjs.com/\"\u003eExpress.js\u003c/a\u003e is a \u003cstrong\u003eminimal and flexible Node.js web application framework\u003c/strong\u003e that provides a robust set of features for web and mobile applications. It‚Äôs been around since 2010 and is known for its simplicity and speed.\u003c/p\u003e","title":"Express.js vs NestJS: Which One Should You Choose?","url":"/express-js-vs-nest-js/"},{"content":"Let‚Äôs explore some essential CSS tips and tricks that will help you streamline your web design process and build stunning, creative websites.\nCSS Clip-Path Clip path allows you to create custom shapes by clipping the visible area of an HTML element. You can think of it as a virtual pair of scissors that allows you to cut and reshape your items. By manipulating this property, you can create various shapes and effects that go beyond the typical rectangles and squares.\n/* Let\u0026#39;s create a circle */ .circular-element { width: 100px; height: 100px; background-color: #3498db; clip-path: circle(50% at 50% 50%); } /*Or a hexagon*/ .hexagon-element { width: 100px; height: 100px; background-color: #e74c3c; clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%); } Creating shapes solely through coding can be challenging. Therefore, you can simplify the process by using a ‚Äúclip-path generator‚Äù tool available online. With this tool, you can draw your desired shapes interactively on a canvas and easily copy the generated code to paste it into your CSS file. (Here is my recommendation.)\nCSS Aspect Ratio Aspect ration is the proportional relationship between the width and height. By defining the aspect ratio of an element, you ensure that it adapts gracefully to various screen sizes and orientations. This is particularly important for images, videos, and containers that house dynamic content.\n.video-container { width:1920px; height:1080px } There‚Äôs nothing inherently wrong with this video player, but the real challenge arises when ensuring its responsiveness across various screen sizes. Writing code to maintain the same proportions for every responsive breakpoint can be quite cumbersome. However, a solution to this challenge is to leverage the aspect-ratio property.\n.video-container { width:100% aspect-ratio: 16/9; } CSS Filters CSS filters are a set of properties that allow you to apply various graphical effects to HTML elements. These effects alter the rendering of an element‚Äôs content and are commonly used for images but can be applied to any HTML content.\n.my-element { filter: blur(5px) grayscale(50%); } Here are some of the most commonly used CSS filters and how they can transform your web design:\nglowing highlighted text\rBlur:\rThe blur filter adds a Gaussian blur to an element, creating a soft and dreamy effect. It‚Äôs perfect for creating focus on a specific part of an image or for adding an artistic touch to your design.\nGrayscale:\rWith the grayscale filter, you can turn colorful elements into black and white, giving your design a classic and timeless look. This filter is great for creating a vintage vibe.\nBrightness and Contrast:\rAdjusting the brightness and contrast filters can make your elements pop or create a subtle, muted appearance. These filters are excellent for fine-tuning the visual balance of your design.\nHue Rotate:\rThe hue-rotate filter allows you to change the color tone of an element, making it easy to create visually stunning effects and color variations.\nInvert:\rThe invert filter flips the colors of an element, making it look like a photographic negative. This can be a captivating and unexpected addition to your web design.\nSaturate and Sepia:\rThe saturate filter intensifies or desaturates colors, while the sepia filter gives your elements a nostalgic, sepia-toned look. Both are fantastic tools for adding character and mood to your design.\nThe :where() Pseudo-Class* This class allows you to select elements that match any of the given selectors within its parentheses. This feature is especially helpful when you want to apply the same styles to multiple similar elements without writing separate rules for each selector.\n/* Without :where() */ div.container h2, div.container h3, div.container h4 { font-weight: bold; } /* With :where() */ :where(h2, h3, h4) { font-weight: bold; } Styling Video Captions Did you know you can give a style for video captions?\nBefore styling, let me show you how to add a caption for a video in HTML.\n\u0026lt;video src=\u0026#34;video.mp4\u0026#34; controls\u0026gt; \u0026lt;track kind=\u0026#34;captions\u0026#34; label=\u0026#34;En\u0026#34; src=\u0026#34;/captions.vtt\u0026#34; /\u0026gt; \u0026lt;/video\u0026gt; As you can see, adding a caption in HTML is quite straightforward. Simply create your caption file in .vtt format and then include it using the track HTML element.\nNow using ::cue pseudo-element, you change your text and font style.\n::cue { font-size: 50px; } Thanks for taking the time to read this article. If you found it helpful, don‚Äôt forget to check out the video on my YouTube channel for even more insights. See you next week for another exciting update\n","summary":"\u003cp\u003eLet‚Äôs explore some essential CSS tips and tricks that will help you streamline your web design process and build stunning, creative websites.\u003c/p\u003e\n\u003ch2 id=\"css-clip-path\"\u003eCSS Clip-Path\u003c/h2\u003e\n\u003cp\u003eClip path allows you to create custom shapes by clipping the visible area of an HTML element. You can think of it as a virtual pair of scissors that allows you to cut and reshape your items. By manipulating this property, you can create various shapes and effects that go beyond the typical rectangles and squares.\u003c/p\u003e","title":"5 CSS Tips and Tricks Every Web Developer Should Know","url":"/css-tips-and-tricks/"},{"content":"To create a blog post in Hugo that includes code snippets with proper syntax highlighting and descriptions, follow these steps:\n1. Create a New Blog Post:\nUse Hugo\u0026rsquo;s command-line tool to generate a new post. Open your terminal and run:\nhugo new posts/your-post-title.md Replace your-post-title.md with your desired filename. This command creates a new Markdown file in the content/posts directory.\n2. Add Content to the Post:\nOpen the newly created Markdown file in your preferred text editor. Add your content, including code snippets. Hugo offers multiple methods to include code snippets with syntax highlighting:\na. Using Markdown Code Fences:\nHugo supports syntax highlighting using code fences. Specify the language after the opening backticks for proper highlighting.\nThis method provides basic syntax highlighting based on the specified language.\nb. Using Hugo\u0026rsquo;s highlight Shortcode:\nHugo\u0026rsquo;s built-in highlight shortcode offers advanced syntax highlighting features, such as line numbers and line highlighting.\ndef hello_world(): ``` ```print(\"Hello, World!\") In this example, line numbers are displayed in a table format, and the second line is highlighted.\nc. Embedding GitHub Gists:\nTo embed code snippets stored in GitHub Gists, use Hugo\u0026rsquo;s gist shortcode. First, create a Gist on GitHub and copy its ID. Then, embed it in your post as follows:\nReplace gist_id with the actual ID of your Gist. This method allows you to maintain code snippets externally and embed them in multiple posts.\n3. Configure Syntax Highlighting:\nEnsure that Hugo\u0026rsquo;s syntax highlighting is enabled and configured in your config.toml file. Add or update the [markup] section as follows:\n[markup] [markup.highlight] noClasses = false style = \u0026#34;monokai\u0026#34; lineNos = true This configuration enables syntax highlighting with the \u0026ldquo;monokai\u0026rdquo; style and displays line numbers.\n4. Add Descriptions and Explanations:\nProvide clear descriptions and explanations before or after each code snippet to help readers understand the context and functionality of the code.\n5. Test and Preview Your Post:\nRun the Hugo server to preview your post locally:\nhugo server Visit http://localhost:1313 in your browser to ensure that the code snippets render correctly with syntax highlighting and that the content appears as intended.\n6. Deploy Your Site:\nAfter verifying your post, deploy your Hugo site using your preferred deployment method, such as GitHub Pages or Netlify.\nBy following these steps, you can create informative blog posts in Hugo that include well-formatted code snippets and descriptions, enhancing the readability and usefulness of your content.\n","summary":"\u003cp\u003eTo create a blog post in Hugo that includes code snippets with proper syntax highlighting and descriptions, follow these steps:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Create a New Blog Post:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eUse Hugo\u0026rsquo;s command-line tool to generate a new post. Open your terminal and run:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehugo new posts/your-post-title.md\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eReplace \u003ccode\u003eyour-post-title.md\u003c/code\u003e with your desired filename. This command creates a new Markdown file in the \u003ccode\u003econtent/posts\u003c/code\u003e directory.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2. Add Content to the Post:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eOpen the newly created Markdown file in your preferred text editor. Add your content, including code snippets. Hugo offers multiple methods to include code snippets with syntax highlighting:\u003c/p\u003e","title":"My Fifth Post My Fifth Post My Fifth Post ","url":"/my-fifth-post/"},{"content":"Authentication and authorization are crucial for any app to stay secure and work properly. Even the slightest oversight can lead to significant problems.\nWhen it comes to Next.js, Auth.js is a popular choice for handling authentication. However, its documentation is overly complex, often leaving developers puzzled. It‚Äôs maintained by a small team, struggles with the challenges of upkeep and maintenance. They haven‚Äôt yet migrated the old next-auth library to auth.js and the compatible version with the new Next.js features is still in beta.\nIf you‚Äôre hesitant to use complex third-party libraries like Auth.js or paid authentication services like Clerk, let‚Äôs explore a simpler approach to user authentication using the ‚Äòiron-session‚Äô library.\nThis library simplifies the process by creating signed and encrypted cookies, facilitating the easy management of user sessions. With server-side encryption and decryption, it prioritizes security and data integrity.\nLet‚Äôs see how to use it to manage sessions, leveraging the latest features like the App router, React server components, and server actions. If you want to watch the full tutorial (more detailed version of this post), please check out my youtube video.\nFirstly, we need to install the library.\nnpm install iron-session\nBefore diving into component creation, let‚Äôs handle the session options and server actions. We‚Äôll require three key actions to effectively manage sessions: a login action to create a signed session, a logout action to terminate the session, and a getSession action to retrieve the user session for validation purposes.\nLet‚Äôs create a file called lib.ts and define the session data type and cookie options.\nimport {SessionOptions} from \u0026#34;iron-session\u0026#34;; export interface SessionData { userId?: string; username?: string; img?: string; isLoggedIn: boolean; } export const defaultSession: SessionData = { isLoggedIn: false, }; export const sessionOptions: SessionOptions = { // You need to create a secret key at least 32 characters long. password: process.env.SESSION_SECRET!, cookieName: \u0026#34;lama-session\u0026#34;, cookieOptions: { httpOnly: true, // Secure only works in `https` environments. So if the environment is `https`, it\u0026#39;ll return true. secure: process.env.NODE_ENV === \u0026#34;production\u0026#34;, }, }; I preferred to use user id, username and user image for the user data, but feel free to store any additional information you deem necessary. Upon user login, we‚Äôll retrieve the user details from the database and store them within the session.\nThen I created the session options. This will encrypt the session with the given secret key.\nYou can generate a secret key using this code on your terminal.\nopenssl rand -base64 32 After that we are ready to create out first action. Create a file called actions.ts and add the following code.\n\u0026ldquo;use server\u0026rdquo;\nimport { SessionData } from \u0026ldquo;@/lib\u0026rdquo;; import { defaultSession, sessionOptions } from \u0026ldquo;@/lib\u0026rdquo;; import { getIronSession } from \u0026ldquo;iron-session\u0026rdquo;; import { cookies } from \u0026ldquo;next/headers\u0026rdquo;; import { redirect } from \u0026ldquo;next/navigation\u0026rdquo;; We created SessionData, defaultSession and sessionOptions in the previous step. We also need Next.js cookies to get the session from the user, getIronSession function to decrypt it with the provided cookie and session options, and redirect function to redirect user to the homepage after the login/logout process.\nLet‚Äôs add the login action.\n\u0026ldquo;use server\u0026rdquo;\nimport { SessionData } from \u0026ldquo;@/lib\u0026rdquo;; import { defaultSession, sessionOptions } from \u0026ldquo;@/lib\u0026rdquo;; import { getIronSession } from \u0026ldquo;iron-session\u0026rdquo;; import { cookies } from \u0026ldquo;next/headers\u0026rdquo;; import { redirect } from \u0026ldquo;next/navigation\u0026rdquo;;\n// ADD THE LOGIN ACTION export async function login( formData: FormData ) { const session = await getSession();\nconst formUsername = formData.get(\u0026ldquo;username\u0026rdquo;) as string; const formPassword = formData.get(\u0026ldquo;password\u0026rdquo;) as string;\n// CHECK USER IN DB USING THE USERNAME AND PASSWORD // it depends on your database (mongoose,prisma,drizzle etc.) // for the testing purpose, I assigned a dummy user const user = { id:1, username:formUsername, img:\u0026ldquo;avatar.png\u0026rdquo; }\n// IF CREDENTIALS ARE WRONG RETURN AN ERROR if(!user){ return { error: \u0026ldquo;Wrong Credentials!\u0026rdquo; } }\n// You can pass any information you want session.isLoggedIn = true; session.id = user.id; session.username = user.username;\nawait session.save(); redirect(\u0026quot;/\u0026quot;) } In the example provided, we retrieve the username and password from the client form and search for the user based on the given credentials. If the user does not exist in the database or the credentials are incorrect, we return an error (which will be displayed to the user using the useFormState hook). If no error occurs, we pass the relevant information to the session and save it using the save() method. This encrypts the session and sends it to the user‚Äôs cookie. Finally, you can redirect the user to the homepage.\nNow, we can create a getSession action to decrypt the user cookie and access the user information.\n\u0026ldquo;use server\u0026rdquo;\nimport { SessionData } from \u0026ldquo;@/lib\u0026rdquo;; import { defaultSession, sessionOptions } from \u0026ldquo;@/lib\u0026rdquo;; import { getIronSession } from \u0026ldquo;iron-session\u0026rdquo;; import { cookies } from \u0026ldquo;next/headers\u0026rdquo;; import { redirect } from \u0026ldquo;next/navigation\u0026rdquo;;\n// ADD THE GETSESSION ACTION export async function getSession() { const session = await getIronSession(cookies(), sessionOptions);\n// If user visits for the first time session returns an empty object. // Let\u0026rsquo;s add the isLoggedIn property to this object and its value will be the default value which is false if (!session.isLoggedIn) { session.isLoggedIn = defaultSession.isLoggedIn; }\nreturn session; }\nexport async function login( formData: FormData ) { const session = await getSession();\nconst formUsername = formData.get(\u0026ldquo;username\u0026rdquo;) as string; const formPassword = formData.get(\u0026ldquo;password\u0026rdquo;) as string;\nconst user = { id:1, username:formUsername, img:\u0026ldquo;avatar.png\u0026rdquo; }\nif(!user){ return { error: \u0026ldquo;Wrong Credentials!\u0026rdquo; } }\nsession.isLoggedIn = true; session.id = user.id; session.username = user.username;\nawait session.save(); redirect(\u0026quot;/\u0026quot;) } Let‚Äôs test it by creating a form. Create a login page and a form component\nimport { getSession } from \u0026ldquo;@/actions\u0026rdquo;; import LoginForm from \u0026ldquo;@/components/loginForm\u0026rdquo;; import { redirect } from \u0026ldquo;next/navigation\u0026rdquo;;\nconst LoginPage = async () =\u0026gt; { const session = await getSession();\nif (session.isLoggedIn) { redirect(\u0026quot;/\u0026quot;); }\nreturn ( Login Page ); };\nexport default LoginPage; \u0026ldquo;use client\u0026rdquo;; import { login } from \u0026ldquo;@/actions\u0026rdquo;; import { useFormState } from \u0026ldquo;react-dom\u0026rdquo;;\nexport default function LoginForm() { const [state, formAction] = useFormState\u0026lt;any, FormData\u0026gt;(login, undefined); return ( Login {state?.error} ); } On the login page, we‚Äôll first fetch the session using the getSession function. If we‚Äôre already logged in, we‚Äôll be redirected to the homepage using the redirect function. However, since we don‚Äôt have a session yet, we‚Äôll remain on this page.\nIn the form action, you can dispatch the login action directly. However, as I mentioned, if there is an error, we‚Äôll display it to the user using the useFormState hook. Initially, the error state is undefined. If an error occurs, we update the state within the login function. To achieve this, let‚Äôs return to the login function and add one more parameter.\nexport async function login( // THIS IS THE PARAMETER THAT WE NEED TO ADD prevState: { error: undefined | string }, formData: FormData ) { const session = await getSession();\nconst formUsername = formData.get(\u0026ldquo;username\u0026rdquo;) as string; const formPassword = formData.get(\u0026ldquo;password\u0026rdquo;) as string;\nconst user = { id:1, username:formUsername, img:\u0026ldquo;avatar.png\u0026rdquo; }\nif(!user){ // IF THERE IS AN ERROR THE STATE WILL BE UPDATED return { error: \u0026ldquo;Wrong Credentials!\u0026rdquo; } }\nsession.isLoggedIn = true; session.id = user.id; session.username = user.username;\nawait session.save(); redirect(\u0026quot;/\u0026quot;) } Currently, clicking the submit button logs you in and redirects you to the homepage. Right now, you cannot see the login page, because we are now logged in, and it‚Äôll redirect us to the homepage automatically.\nTo test the error message, you can define a null user in the login action.\nNow, let‚Äôs proceed to the actions.ts file and create a logout function. Within this function, we‚Äôll execute the process to destroy the session.\n\u0026ldquo;use server\u0026rdquo;\nimport { SessionData } from \u0026ldquo;@/lib\u0026rdquo;; import { defaultSession, sessionOptions } from \u0026ldquo;@/lib\u0026rdquo;; import { getIronSession } from \u0026ldquo;iron-session\u0026rdquo;; import { cookies } from \u0026ldquo;next/headers\u0026rdquo;; import { redirect } from \u0026ldquo;next/navigation\u0026rdquo;;\n// ADD THE LOGOUT FUNCTION export async function logout() { const session = await getSession(); session.destroy(); redirect(\u0026quot;/\u0026quot;) }\nexport async function getSession() { const session = await getIronSession(cookies(), sessionOptions);\nif (!session.isLoggedIn) { session.isLoggedIn = defaultSession.isLoggedIn; }\nreturn session; }\nexport async function login( formData: FormData ) { const session = await getSession();\nconst formUsername = formData.get(\u0026ldquo;username\u0026rdquo;) as string; const formPassword = formData.get(\u0026ldquo;password\u0026rdquo;) as string;\nconst user = { id:1, username:formUsername, img:\u0026ldquo;avatar.png\u0026rdquo; }\nif(!user){ return { error: \u0026ldquo;Wrong Credentials!\u0026rdquo; } }\nsession.isLoggedIn = true; session.id = user.id; session.username = user.username;\nawait session.save(); redirect(\u0026quot;/\u0026quot;) } To test this action, let‚Äôs create a logout form.\nimport { logout } from \u0026ldquo;@/actions\u0026rdquo;;\nexport default function LogoutForm() { return ( Logout ); } And that wraps it up! This method provides a straightforward approach to creating and managing secure authentication cookies. If you‚Äôre interested in delving deeper into managing authorization, creating protected pages, and updating user sessions, be sure to check out my YouTube video for a comprehensive guide.\n","summary":"\u003cp\u003eAuthentication and authorization are crucial for any app to stay secure and work properly. Even the slightest oversight can lead to significant problems.\u003c/p\u003e\n\u003cp\u003eWhen it comes to Next.js, Auth.js is a popular choice for handling authentication. However, its documentation is overly complex, often leaving developers puzzled. It‚Äôs maintained by a small team, struggles with the challenges of upkeep and maintenance. They haven‚Äôt yet migrated the old next-auth library to auth.js and the compatible version with the new Next.js features is still in beta.\u003c/p\u003e","title":"Next.js 14 Auth with Iron Session and Server Actions","url":"/next-auth-with-iron-session/"},{"content":"Two popular frameworks, Next.js and Express, serve different features and purposes. In this blog post, we will explore the differences between Next.js and Express and discuss when and why you might choose one over the other.\nPurpose os Next.js Next.js is a powerful framework built on top of React, focusing on server-rendered and statically generated React applications. It provides a structure for building complex, dynamic web applications and offers features like automatic code splitting, server-side rendering (SSR), and static site generation (SSG). These features enhance performance, improve SEO, and provide faster initial page loads. On top of that, Next.js has a built-in API routing system that allows creating API endpoints securely connecting with third-party services and consuming from the front end. It can also use serverless functions and edge network deployment to build scalable APIs.\nPurpose of Express.js Express is a minimalist web application framework for Node.js, designed for building APIs and server-side applications. Express offers a flexible approach to web development. It enables developers to handle HTTP requests, implement routing, and use middleware efficiently.\nIn a nutshell, we can create backend APIs using both Next.js and Express server. But while Express is well-suited for building RESTful APIs, Next.js is a fullstack framework that you can create an API and use it directly in pages and components dynamically. But which one is better for creating a backend API?\nIs Express Faster than Next.js Routes? It‚Äôs the first question that React developers ask. They are aware of the impressive speed of Express.js and may have concerns about utilizing Next.js API routes. However, in practice, there are no significant performance disparities between these two frameworks. Therefore, there is no need to worry about replacing Express with Next.js. The real issue lies in the caching system of Next.js, which aims to enhance the development experience. Occasionally, this can lead to refreshing problems during the development mode, creating a perception among some developers that an Express-React app performs better than a full-stack Next.js app. However, it‚Äôs important to note that Next.js routes are equally as fast as Express.js routes.\nIt‚Äôs important to consider that the performance of both frameworks can be optimized through various techniques, such as implementing caching mechanisms, optimizing database queries, and applying performance best practices.\nCoding Experience and Readability I must admit that working with an Express server adds a certain level of enjoyment when creating APIs. The clear separation between the backend and frontend, along with the organized folder structure, contributes to a clean and organized workflow. Additionally, Express allows the flexibility of choosing different names for each API route, which can be quite convenient. On the other hand, with Next.js, finding and refactoring ‚Äúroute‚Äù files can occasionally be a frustrating experience. Moreover, the shared folder names between API endpoints and pages can lead to confusion, as it doubles the potential for mix-ups.\nAuthentication When it comes to implementing authentication methods for APIs, there are numerous options available. But in any case, the golden medal is going to Next.js in this topic. Being a full-stack framework, Next.js simplifies the process of handling authentication seamlessly on both the server and client sides, eliminating the need for additional steps. By utilizing Auth.js, you can effortlessly access the user session in both pages and API routes, benefiting from its built-in features such as social authentication and database adapters. On the other hand, in an Express server, you would need to search for different libraries and authentication solutions, which, while not overly challenging, does not offer the same level of convenience as Next.js.\nConclusion A classic conclusion. I know you hate this but: It Depends!\nThe choice between the two frameworks should be based on the specific requirements of your project and personal preferences as a developer. It is important to recognize that there is no specific difference between the two frameworks. When embarking on a project, it‚Äôs best not to get caught up in overthinking the choice of technologies. Instead, dive right in and start creating. As you progress with your project, you will gain a clearer understanding of your specific needs, enabling you to adapt and incorporate alternative technologies if necessary.\nImprovise, Adapt and Overcome!\nSee you next week.\n","summary":"\u003cp\u003eTwo popular frameworks, Next.js and Express, serve different features and purposes. In this blog post, we will explore the differences between Next.js and Express and discuss when and why you might choose one over the other.\u003c/p\u003e\n\u003ch2 id=\"purpose-os-nextjs\"\u003ePurpose os Next.js\u003c/h2\u003e\n\u003cp\u003eNext.js is a powerful framework built on top of React, focusing on server-rendered and statically generated React applications. It provides a structure for building complex, dynamic web applications and offers features like automatic code splitting, server-side rendering (SSR), and static site generation (SSG). These features enhance performance, improve SEO, and provide faster initial page loads. On top of that, Next.js has a built-in API routing system that allows creating API endpoints securely connecting with third-party services and consuming from the front end. It can also use serverless functions and edge network deployment to build scalable APIs.\u003c/p\u003e","title":"Next.js vs Express: Which one is Better for a Backend Server?","url":"/next-vs-express/"},{"content":"The useEffect Hook is a fundamental aspect of React that allows developers to handle side effects in functional components. Introduced in React 16.8, it replaces the need for class-based lifecycle methods, enabling a more streamlined approach to managing side effects such as data fetching, subscriptions, or manually changing the DOM.\nUnderstanding useEffect\nIn functional components, side effects are operations that interact with the outside world or affect the component outside of rendering, such as fetching data from an API, setting up a subscription, or manually manipulating the DOM. The useEffect Hook provides a way to perform these side effects.\nThe basic syntax of useEffect is:\nuseEffect(() =\u0026gt; { // Side effect logic here return () =\u0026gt; { // Cleanup logic here (optional) }; }, [dependencies]); Here, the first argument is a function containing the side effect logic, and the second argument is an optional array of dependencies that determine when the effect should re-run. If the dependencies change, the effect is executed again.\nCommon Use Cases for useEffect\nFetching Data from an API\nOne of the most common use cases for useEffect is fetching data when a component mounts. By providing an empty dependency array, the effect runs only once after the initial render.\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; function DataFetchingComponent() { const [data, setData] = useState([]); useEffect(() =\u0026gt; { async function fetchData() { const response = await fetch(\u0026#39;https://api.example.com/data\u0026#39;); const result = await response.json(); setData(result); } fetchData(); }, []); // Empty dependency array ensures this runs once return ( \u0026lt;div\u0026gt; {data.map(item =\u0026gt; ( \u0026lt;div key={item.id}\u0026gt;{item.name}\u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ); } In this example, fetchData is called once when the component mounts, and the fetched data is stored in the component\u0026rsquo;s state.\nSubscribing to External Data Sources\nuseEffect is also useful for setting up subscriptions to external data sources or event listeners. It\u0026rsquo;s important to clean up these subscriptions to prevent memory leaks.\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; function WindowWidthComponent() { const [width, setWidth] = useState(window.innerWidth); useEffect(() =\u0026gt; { function handleResize() { setWidth(window.innerWidth); } window.addEventListener(\u0026#39;resize\u0026#39;, handleResize); // Cleanup function return () =\u0026gt; { window.removeEventListener(\u0026#39;resize\u0026#39;, handleResize); }; }, []); // Empty dependency array ensures this runs once return \u0026lt;div\u0026gt;Window width: {width}\u0026lt;/div\u0026gt;; } Here, an event listener is added to track window resize events, and the cleanup function removes the listener when the component unmounts.\nAnimating Components on State Change\nuseEffect can trigger animations in response to state changes. For instance, you might want to animate a shopping cart icon when a new item is added.\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; function ShoppingCart({ items }) { const [isAnimating, setIsAnimating] = useState(false); useEffect(() =\u0026gt; { if (items.length \u0026gt; 0) { setIsAnimating(true); const timer = setTimeout(() =\u0026gt; setIsAnimating(false), 300); return () =\u0026gt; clearTimeout(timer); } }, [items]); // Runs when \u0026#39;items\u0026#39; changes return ( \u0026lt;div className={isAnimating ? \u0026#39;cart animate\u0026#39; : \u0026#39;cart\u0026#39;}\u0026gt; {/* Render cart items */} \u0026lt;/div\u0026gt; ); } In this case, the effect watches the items array, and when it changes (i.e., when a new item is added), it triggers an animation that lasts for 300 milliseconds.\nBest Practices for Using useEffect\nSpecify Dependencies Accurately: Always include all state and props that the effect relies on in the dependency array to ensure the effect runs correctly.\nClean Up Side Effects: Return a cleanup function from within the effect to clean up subscriptions or timers, preventing potential memory leaks.\nAvoid Overusing useEffect: Not all logic belongs inside useEffect. For example, computations that can be performed during rendering should not be placed inside useEffect.\nConclusion\nThe useEffect Hook is a powerful tool that simplifies handling side effects in React functional components. By understanding its usage and following best practices, developers can write more efficient and maintainable code. Whether it\u0026rsquo;s fetching data, setting up subscriptions, or triggering animations, useEffect provides a declarative approach to managing side effects in React applications.\nReferences:\nReact useEffect Hooks - W3Schools\nHow the useEffect Hook Works (with Examples) - Dave Ceddia\n6 use cases of the useEffect ReactJS hook - DEV Community\n","summary":"\u003cp\u003eThe \u003ccode\u003euseEffect\u003c/code\u003e Hook is a fundamental aspect of React that allows developers to handle side effects in functional components. Introduced in React 16.8, it replaces the need for class-based lifecycle methods, enabling a more streamlined approach to managing side effects such as data fetching, subscriptions, or manually changing the DOM.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUnderstanding \u003ccode\u003euseEffect\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn functional components, side effects are operations that interact with the outside world or affect the component outside of rendering, such as fetching data from an API, setting up a subscription, or manually manipulating the DOM. The \u003ccode\u003euseEffect\u003c/code\u003e Hook provides a way to perform these side effects.\u003c/p\u003e","title":"Understanding useEffect in React: Use Cases, Examples \u0026 Best Practices","url":"/my-sixth-post/"}]